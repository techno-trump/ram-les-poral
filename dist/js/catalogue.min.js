/******/ (function() { // webpackBootstrap
/******/ 	"use strict";
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other entry modules.
!function() {

;// CONCATENATED MODULE: ./repo/js/libs/logger.js
const onlyErrorsToConsole = true;
const consoleLogs = true;
const consoleDebug = true;
const alertOnError = false;
const alertOnLog = false;
function log() {
  if (!onlyErrorsToConsole) {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (consoleLogs) console.log(...args);
    if (alertOnLog) alert(args.join(" :: "));
  }
}
function debug() {
  if (!onlyErrorsToConsole && consoleDebug) console.debug(...arguments);
}
function error() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }
  if (!onlyErrorsToConsole && consoleDebug) console.error(...args);
  if (alertOnError) alert(args.join(" :: "));
}
;// CONCATENATED MODULE: ./src/js/pages/catalogue/sliders.js

function initCardsSlider(selector) {
  log("initCardsSlider::selector: ", selector);
  let slider;
  const mediaMatch = matchMedia("(max-width: 575px)");
  const handleMatch = _ref => {
    let {
      matches
    } = _ref;
    if (matches) {
      if (!slider) {
        slider = init();
      }
    } else if (slider && slider.initialized) {
      slider.destroy();
      slider = null;
    }
  };
  mediaMatch.addListener(handleMatch);
  handleMatch(mediaMatch);
  function init() {
    return new Swiper(selector, {
      observer: true,
      resizeObserver: true,
      slidesPerView: 1,
      grabCursor: true,
      autoplay: {
        delay: 5000
      }
    });
  }
}
// function initFiltersSlider() {
// 	new Swiper("#filters-slider", {
// 		observer: true,
// 		resizeObserver: true,
// 		slidesPerView: "auto",
// 		grabCursor: true,
// 		spaceBetween: 30,
// 	});
// }

function initSliders() {
  initCardsSlider("#catalogue-slider");
  //initCardsSlider("#popular-slider");
  //initFiltersSlider();
}
;// CONCATENATED MODULE: ./repo/js/libs/input-service-classes.js
function initInputFocusTracking() {
  let root = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
  const nodes = root.querySelectorAll("[data-focus-receiver]");
  nodes.forEach(node => {
    const focusIndicator = node.closest("[data-focus-indicator]");
    if (focusIndicator) {
      node.addEventListener("focus", e => {
        focusIndicator.classList.add("focus");
      });
      node.addEventListener("blur", e => {
        focusIndicator.classList.remove("focus");
      });
    }
  });
}
function initInputCheckTracking() {
  let root = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
  const nodes = root.querySelectorAll("[data-check-receiver]");
  nodes.forEach(node => {
    const indicator = node.closest("[data-check-indicator]");
    if (indicator) {
      if (node.checked) {
        indicator.classList.add("checked");
      }
      node.addEventListener("change", e => {
        if (e.currentTarget.checked) {
          indicator.classList.add("checked");
        } else {
          indicator.classList.remove("checked");
        }
      });
    }
  });
}
function initRadioCheckTracking() {
  let root = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
  const elems = root.querySelectorAll("[data-radio]");
  let checked = {};
  elems.forEach(elem => {
    var _elem$form;
    const indicator = elem.closest("[data-radio-wrapper]");
    const formName = ((_elem$form = elem.form) === null || _elem$form === void 0 ? void 0 : _elem$form.getAttribute("name")) || "";
    const name = elem.name;
    if (indicator) {
      if (elem.checked) {
        indicator.classList.add("checked");
        checked["".concat(formName, "__").concat(name)] = indicator;
      }
      elem.addEventListener("change", event => {
        if (event.currentTarget.checked) {
          indicator.classList.add("checked");
          if (checked["".concat(formName, "__").concat(name)] && checked["".concat(formName, "__").concat(name)] !== indicator) {
            checked["".concat(formName, "__").concat(name)].classList.remove("checked");
            checked["".concat(formName, "__").concat(name)] = indicator;
          }
          checked["".concat(formName, "__").concat(name)] = indicator;
        } else {
          indicator.classList.remove("checked");
        }
      });
    }
  });
}
function trackFocus() {
  let root = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
  const targetElems = root.querySelectorAll("[data-track-child-focus]");
  targetElems.forEach(elem => {
    elem.addEventListener("focusin", e => {
      elem.classList.add("_focus");
    });
    elem.addEventListener("focusout", e => {
      elem.classList.remove("_focus");
    });
  });
}
function inputAutoSize() {
  const targetElems = document.querySelectorAll("[data-input-auto-size]");
  targetElems.forEach(elem => {
    const handler = e => {
      setTimeout(() => {
        e.target.style.width = "1px";
        requestAnimationFrame(() => {
          e.target.style.width = "".concat(e.target.scrollWidth, "px");
        });
      }, 1);
    };
    elem.addEventListener("blur", handler);
    elem.addEventListener("change", handler);
    elem.addEventListener("input", handler);
    handler({
      target: elem
    });
  });
}
;// CONCATENATED MODULE: ./repo/js/libs/utils.js
function isEmpty(value) {
  return value === null || value === undefined || value === "";
}
function getTargetElem(target) {
  if (target instanceof HTMLElement) {
    return target;
  } else {
    const elem = document.querySelector(target);
    if (!elem) new Error("Cannot find the target by selector: ".concat(target));
    return elem;
  }
}
function formatPrice(value) {
  const normalizedValue = typeof value === "string" ? value.trim().replace(" ", "") : String(value);
  const result = [];
  const tmp = normalizedValue.split("");
  // return normalizedValue.split(/\B(?=(\d{3})+$)/).join(" ");
  while (tmp.length > 0) {
    result.unshift(tmp.splice(-3).join(""));
  }
  return result.join(" ");
}
function forEachProp(obj, callback) {
  var keys = Object.keys(obj);
  for (var i = 0; i < keys.length; i++) {
    callback(keys[i], obj[keys[i]]);
  }
}
;
const createElem = (name, attrs, container) => {
  var el = document.createElement(name);
  if (attrs) forEachProp(attrs, function (key, value) {
    return el.setAttribute(key, value);
  });
  if (container) container.appendChild(el);
  return el;
};
const normalizeString = value => {
  return String(value).toLowerCase().trim();
};
const isMobile = {
  Android: function () {
    return navigator.userAgent.match(/Android/i);
  },
  BlackBerry: function () {
    return navigator.userAgent.match(/BlackBerry/i);
  },
  iOS: function () {
    return navigator.userAgent.match(/iPhone|iPad|iPod/i);
  },
  Opera: function () {
    return navigator.userAgent.match(/Opera Mini/i);
  },
  Windows: function () {
    return navigator.userAgent.match(/IEMobile/i);
  },
  any: function () {
    return isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows();
  }
};
;// CONCATENATED MODULE: ./repo/js/libs/double-range-slider.js


class DoubleRangeSlider {
  constructor(target) {
    this.rootElem = getTargetElem(target);
    if (!this.rootElem) return null;
    this.alias = this.rootElem.getAttribute("data-double-range-slider");
    this.rangeFromElem = this.rootElem.querySelector(".double-range-slider__from");
    this.rangeToElem = this.rootElem.querySelector(".double-range-slider__to");
    const [fromValue, toValue] = getInputValues(this.rangeFromElem, this.rangeToElem);
    this.updateSelection(fromValue, toValue);
    const fromChangeHandler = e => {
      const [fromValue, toValue] = getInputValues(this.rangeFromElem, this.rangeToElem);
      if (fromValue > toValue) {
        this.rangeFromElem.value = toValue;
      }
      this.updateSelection(fromValue, toValue);
    };
    const toChangeHandler = e => {
      const [fromValue, toValue] = getInputValues(this.rangeFromElem, this.rangeToElem);
      if (toValue < fromValue) {
        this.rangeToElem.value = fromValue;
      }
      this.updateSelection(fromValue, toValue);
    };
    this.rangeFromElem.addEventListener("input", fromChangeHandler);
    this.rangeToElem.addEventListener("input", toChangeHandler);
    this.rangeFromElem.addEventListener("change", fromChangeHandler);
    this.rangeToElem.addEventListener("change", toChangeHandler);
    if (this.rootElem.hasAttribute("data-sync-with-inputs")) {
      this.initSync();
    }
  }
  updateSelection(fromValue, toValue) {
    const [minValue, maxValue] = this.getMinMax();
    const range = maxValue - minValue;
    const posFrom = (fromValue - minValue) / range * 100;
    const posTo = (toValue - minValue) / range * 100;
    this.rangeFromElem.style.setProperty("--selected-from", "".concat(posFrom.toFixed(2), "%"));
    this.rangeFromElem.style.setProperty("--selected-to", "".concat(posTo.toFixed(2), "%"));
  }
  initSync() {
    const inputElems = document.querySelectorAll("[data-range-input-from=\"".concat(this.alias, "\"], [data-range-input-to=\"").concat(this.alias, "\"]"));
    log("initSync::inputElems", inputElems);
    if (inputElems.length !== 2) return;
    if (inputElems[0].hasAttribute("data-range-input-from")) {
      this.inputFromElem = inputElems[0];
      this.inputToElem = inputElems[1];
    } else {
      this.inputFromElem = inputElems[1];
      this.inputToElem = inputElems[0];
    }
    const inputFromChangeHandler = event => {
      if (!event.__sync) {
        const {
          target
        } = event;
        const value = stripNumberFormat(target.value) || "0";
        const [minValue, maxValue] = this.getMinMax();
        const normalizedValue = Math.max(minValue, Math.min(value, parseInt(this.rangeToElem.value, 10)));
        target.value = normalizedValue;
        this.rangeFromElem.value = normalizedValue;
        emitEvent(target, "input");
        emitEvent(this.rangeFromElem, "input");
      }
    };
    const inputToChangeHandler = event => {
      if (!event.__sync) {
        const {
          target
        } = event;
        const value = stripNumberFormat(target.value) || "0";
        const [minValue, maxValue] = this.getMinMax();
        const normalizedValue = Math.min(maxValue, Math.max(value, parseInt(this.rangeFromElem.value, 10)));
        target.value = normalizedValue;
        this.rangeToElem.value = normalizedValue;
        emitEvent(target, "input");
        emitEvent(this.rangeToElem, "input");
      }
    };
    const rangeFromChangeHandler = event => {
      if (!event.__sync) {
        const {
          target
        } = event;
        this.inputFromElem.value = target.value;
        emitEvent(this.inputFromElem, "input");
      }
    };
    const rangeToChangeHandler = event => {
      if (!event.__sync) {
        const {
          target
        } = event;
        this.inputToElem.value = target.value;
        emitEvent(this.inputToElem, "input");
      }
    };
    this.inputFromElem.value = this.rangeFromElem.value;
    this.inputToElem.value = this.rangeToElem.value;
    emitEvent(this.inputFromElem, "input");
    emitEvent(this.inputToElem, "input");
    this.inputFromElem.addEventListener("change", inputFromChangeHandler);
    this.inputToElem.addEventListener("change", inputToChangeHandler);
    this.rangeFromElem.addEventListener("input", rangeFromChangeHandler);
    this.rangeToElem.addEventListener("input", rangeToChangeHandler);
    function emitEvent(elem, type) {
      const event = new Event(type);
      event.__sync = true;
      elem.dispatchEvent(event);
    }
  }
  getMinMax() {
    return [parseInt(this.rangeFromElem.getAttribute("min"), 10) || 0, parseInt(this.rangeFromElem.getAttribute("max"), 10) || 100];
  }
}
function initDoubleRangeSliders() {
  const rootElems = document.querySelectorAll("[data-double-range-slider]");
  rootElems.forEach(rootElem => {
    new DoubleRangeSlider(rootElem);
  });
}
function getInputValues(elemFrom, elemTo) {
  return [parseInt(elemFrom.value, 10), parseInt(elemTo.value, 10)];
}
function stripNumberFormat(value) {
  return parseInt(value.replace(/[,\.\s]/g, ""), 10);
}
;// CONCATENATED MODULE: ./src/js/pages/catalogue/index.js




window.addEventListener("DOMContentLoaded", onLoaded);
function onLoaded() {
  initSliders();
  inputAutoSize();
  initDoubleRangeSliders();
  initPriceFormat(document.querySelector("#price-from"));
  initPriceFormat(document.querySelector("#price-to"));
  initFiltersSync();
  initFiltersReset();
}
function initPriceFormat(elem) {
  const cleave = new Cleave(elem, {
    delimiter: ' ',
    numeral: true,
    numeralThousandsGroupStyle: 'thousand'
  });
}
function initFiltersSync() {
  syncCheckboxes(document.querySelectorAll("#main-filter--floors--one, #short-filter--one-floor-houses"));
  syncCheckboxes(document.querySelectorAll("#main-filter--floors--two, #short-filter--two-floors-houses"));
  syncCheckboxes(document.querySelectorAll("#main-filter--guest-houses, #short-filter--guest-houses"));
  function syncCheckboxes(list) {
    const changeHandler = event => {
      if (event.__sync) return;
      list.forEach(elem => {
        if (elem === event.target) return;
        elem.checked = event.target.checked;
        emitChangeEvent(elem, true);
      });
    };
    list.forEach(elem => {
      elem.addEventListener("change", changeHandler);
    });
  }
}
function emitChangeEvent(elem) {
  let sync = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  const event = new Event("change", {
    bubbles: true
  });
  event.__sync = sync;
  elem.dispatchEvent(event);
}
function emitInputEvent(elem) {
  let sync = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  const event = new Event("input", {
    bubbles: true
  });
  event.__sync = sync;
  elem.dispatchEvent(event);
}
function initFiltersReset() {
  const btnElem = document.querySelector("#main-filter-reset");
  const checkboxes = document.querySelectorAll("form[name='main-filter'] input[type='checkbox']");
  const priceFromElem = document.querySelector("#main-filter--price-from");
  const priceToElel = document.querySelector("#main-filter--price-to");
  const squareFromElem = document.querySelector("#main-filter--square-from");
  const squareToElel = document.querySelector("#main-filter--square-to");
  btnElem.addEventListener("click", event => {
    checkboxes.forEach(elem => {
      elem.checked = false;
      emitChangeEvent(elem);
    });
    resetRange(priceFromElem, priceToElel);
    resetRange(squareFromElem, squareToElel);
  });
  function resetRange(fromElem, toElem) {
    fromElem.value = fromElem.getAttribute("min") || 0;
    toElem.value = fromElem.getAttribute("max") || 100;
    emitInputEvent(fromElem);
    emitInputEvent(toElem);
  }
}
}();
// This entry need to be wrapped in an IIFE because it need to be isolated against other entry modules.
!function() {
// extracted by mini-css-extract-plugin

}();
/******/ })()
;