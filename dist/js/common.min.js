/******/ (function() { // webpackBootstrap
/******/ 	"use strict";
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other entry modules.
!function() {

;// CONCATENATED MODULE: ./repo/js/libs/logger.js
const onlyErrorsToConsole = true;
const consoleLogs = true;
const consoleDebug = true;
const alertOnError = false;
const alertOnLog = false;
function log() {
  if (!onlyErrorsToConsole) {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (consoleLogs) console.log(...args);
    if (alertOnLog) alert(args.join(" :: "));
  }
}
function debug() {
  if (!onlyErrorsToConsole && consoleDebug) console.debug(...arguments);
}
function error() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }
  if (!onlyErrorsToConsole && consoleDebug) console.error(...args);
  if (alertOnError) alert(args.join(" :: "));
}
;// CONCATENATED MODULE: ./repo/js/libs/utils.js
function isEmpty(value) {
  return value === null || value === undefined || value === "";
}
function getTargetElem(target) {
  if (target instanceof HTMLElement) {
    return target;
  } else {
    const elem = document.querySelector(target);
    if (!elem) new Error("Cannot find the target by selector: ".concat(target));
    return elem;
  }
}
function formatPrice(value) {
  const normalizedValue = typeof value === "string" ? value.trim().replace(" ", "") : String(value);
  const result = [];
  const tmp = normalizedValue.split("");
  // return normalizedValue.split(/\B(?=(\d{3})+$)/).join(" ");
  while (tmp.length > 0) {
    result.unshift(tmp.splice(-3).join(""));
  }
  return result.join(" ");
}
function forEachProp(obj, callback) {
  var keys = Object.keys(obj);
  for (var i = 0; i < keys.length; i++) {
    callback(keys[i], obj[keys[i]]);
  }
}
;
const createElem = (name, attrs, container) => {
  var el = document.createElement(name);
  if (attrs) forEachProp(attrs, function (key, value) {
    return el.setAttribute(key, value);
  });
  if (container) container.appendChild(el);
  return el;
};
const normalizeString = value => {
  return String(value).toLowerCase().trim();
};
const isMobile = {
  Android: function () {
    return navigator.userAgent.match(/Android/i);
  },
  BlackBerry: function () {
    return navigator.userAgent.match(/BlackBerry/i);
  },
  iOS: function () {
    return navigator.userAgent.match(/iPhone|iPad|iPod/i);
  },
  Opera: function () {
    return navigator.userAgent.match(/Opera Mini/i);
  },
  Windows: function () {
    return navigator.userAgent.match(/IEMobile/i);
  },
  any: function () {
    return isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows();
  }
};
;// CONCATENATED MODULE: ./repo/components/drawers/index.js
function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }
function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }
function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }
function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }


log("Started loading drawers api to global scope");
const {
  lock,
  unlock
} = bodyScrollLock;
const isAsync = target => target.constructor.name === "AsyncFunction";
const initialLayerZIndex = 200;
const defaultOptions = {
  overlapping: true,
  static: false,
  closeOnEsc: true,
  closeOnOutsideClick: true,
  closeConfirm: drawer => {
    return true;
  }
};
var _state = /*#__PURE__*/new WeakMap();
class Drawer {
  static get upperOpenDrawer() {
    return Drawer.openDrawersList[Drawer.openDrawersList.length - 1];
  }
  static get upperOverlapping() {
    return Drawer.state.upperOverlapping;
  }
  static set upperOverlapping(drawer) {
    return Drawer.state.upperOverlapping = drawer;
  }
  static resetUpperOverlapping() {
    if (Drawer.upperOverlapping) {
      Drawer.upperOverlapping.upperOverlapping = false;
    }
    const upperOverlapping = Drawer.openDrawersList.find(drawer => drawer.overlapping);
    if (upperOverlapping) {
      upperOverlapping.upperOverlapping = true;
      Drawer.upperOverlapping = upperOverlapping;
    }
  }
  static get upperZIndex() {
    if (Drawer.openDrawersList.length) {
      return Drawer.upperOpenDrawer.zIndex;
    } else {
      return initialLayerZIndex;
    }
  }
  constructor(elem, alias) {
    let userOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    _classPrivateFieldInitSpec(this, _state, {
      writable: true,
      value: {
        zIndex: null,
        focus: false,
        open: false,
        locked: false,
        upperOverlapping: false
      }
    });
    _defineProperty(this, "subscribers", {
      close: [],
      open: []
    });
    _defineProperty(this, "components", {
      openBtnElems: [],
      closeBtnElems: []
    });
    const options = {
      __proto__: defaultOptions,
      on: {}
    };
    this.elem = elem;
    this.alias = alias;
    this.params = Object.assign(options, userOptions);
    debug("Drawer has been initialized: ", alias);
  }
  set zIndex(val) {
    _classPrivateFieldGet(this, _state).zIndex = val;
    this.elem.style.setProperty("z-index", val);
  }
  get zIndex() {
    return _classPrivateFieldGet(this, _state).zIndex;
  }
  set focus(value) {
    _classPrivateFieldGet(this, _state).focus = value;
    if (value) {
      this.elem.classList.add("focus");
    } else {
      this.elem.classList.remove("focus");
    }
  }
  set upperOverlapping(value) {
    _classPrivateFieldGet(this, _state).upperOverlapping = value;
    if (value) {
      this.elem.classList.add("upper-overlapping");
    } else {
      this.elem.classList.remove("upper-overlapping");
    }
  }
  get upperOverlapping() {
    return _classPrivateFieldGet(this, _state).upperOverlapping;
  }
  get focus() {
    return _classPrivateFieldGet(this, _state).focus;
  }
  set locked(value) {
    _classPrivateFieldGet(this, _state).locked = value;
    if (value) bodyLock(this.elem);else bodyUnlock(this.elem);
  }
  get locked() {
    return _classPrivateFieldGet(this, _state).locked;
  }
  on(type, callback) {
    if (type in this.subscribers) {
      this.subscribers[type].push(callback);
    }
  }
  set overlapping(value) {
    this.params.overlapping = value;
    if (value) this.elem.classList.add("drawer_overlapping");else this.elem.classList.remove("drawer_overlapping");
    Drawer.resetUpperOverlapping();
  }
  get overlapping() {
    return this.params.overlapping;
  }
  addOpenBtn(target) {
    const openBtnElem = getTargetElem(target);
    this.components.openBtnElems.push(openBtnElem);
    openBtnElem.addEventListener("click", event => {
      event.__drawerOpen = true;
      this.open(openBtnElem);
    });
  }
  addCloseBtn(target) {
    const closeBtnElem = getTargetElem(target);
    this.components.closeBtnElems.push(closeBtnElem);
    closeBtnElem.addEventListener("click", event => {
      event.__drawerClose = true;
      this.close(closeBtnElem);
    });
  }
  open(initiator) {
    console.log("Open Drawer Native", this, initiator);
    if (_classPrivateFieldGet(this, _state).open) return;
    this.components.openBtnElems.forEach(elem => {
      if (elem instanceof HTMLElement) {
        elem.classList.add("active");
      }
    });
    this.components.closeBtnElems.forEach(elem => {
      if (elem instanceof HTMLElement) {
        elem.classList.add("active");
      }
    });
    if (this.params.overlapping || this.params.static) {
      // Add event listeners
      this.locked = true;
      if (Drawer.upperOverlapping) {
        Drawer.upperOverlapping.upperOverlapping = false;
      }
      this.upperOverlapping = true;
      Drawer.upperOverlapping = this;
    }
    // Get upper overlapping
    this.zIndex = Drawer.upperZIndex + 1;
    this.elem.classList.add("open");
    this.initiator = initiator;
    _classPrivateFieldGet(this, _state).open = true;
    Drawer.openDrawersList.push(this);
    this.subscribers.open.forEach(callback => callback(this));
  }
  close() {
    console.log("Close Drawer Native", this);
    if (!_classPrivateFieldGet(this, _state).open) return;
    this.components.openBtnElems.forEach(elem => {
      if (elem instanceof HTMLElement) {
        elem.classList.remove("active");
      }
    });
    this.components.closeBtnElems.forEach(elem => {
      if (elem instanceof HTMLElement) {
        elem.classList.remove("active");
      }
    });
    this.elem.classList.remove("open");
    this.locked = false;
    _classPrivateFieldGet(this, _state).open = false;
    const drawerIdx = Drawer.openDrawersList.findIndex(drawer => drawer.alias === this.alias);
    Drawer.openDrawersList.splice(drawerIdx, 1);
    Drawer.resetUpperOverlapping();
    this.subscribers.close.forEach(callback => callback(this));
  }
  async handleEsc(event) {
    if (this.params.closeOnEsc && !this.params.static) {
      if (await this.params.closeConfirm(this)) this.close();
    }
  }
  async handleOutsideClick(event) {
    if (event.target === this.initiator) return;
    if (this.params.closeOnOutsideClick && !this.params.static) {
      if (await this.params.closeConfirm(this)) this.close();
    }
  }
  async handleUnderlayClick(event) {
    if (this.params.closeOnOutsideClick && !this.params.static) {
      if (await this.params.closeConfirm(this)) this.close();
    }
  }
}
_defineProperty(Drawer, "openDrawersList", []);
_defineProperty(Drawer, "state", {
  upperOverlapping: null
});
if (!window.drawers) {
  window.drawers = (() => {
    const kitchen = {};
    const drawersMap = {};
    kitchen.init = function (options) {
      debug("Start drawers initialization");
      const drawerElems = document.querySelectorAll("[data-drawer]");
      const controlElems = document.querySelectorAll("[data-drawer-open], [data-drawer-close]");
      drawerElems.forEach(elem => {
        const drawerAlias = elem.getAttribute("data-drawer");
        drawersMap[drawerAlias] = new Drawer(elem, drawerAlias, options);
      });
      controlElems.forEach(elem => {
        if (elem.hasAttribute("data-drawer-open")) {
          const drawerAlias = elem.getAttribute("data-drawer-open");
          if (!drawersMap[drawerAlias]) return;
          drawersMap[drawerAlias].addOpenBtn(elem);
        } else {
          const drawerAlias = elem.getAttribute("data-drawer-close");
          if (!drawersMap[drawerAlias]) return;
          drawersMap[drawerAlias].addCloseBtn(elem);
        }
      });
      document.addEventListener("click", event => {
        if (event.__drawerOpen || event.__drawerClose) return;
        const {
          target
        } = event;
        const drawerPanelElem = target.closest(".drawer__panel");
        if (drawerPanelElem) {// Inside click
        } else {
          const drawerElem = target.closest(".drawer");
          if (drawerElem) {
            var _drawersMap$alias;
            // Underlay click
            const alias = drawerElem.getAttribute("data-drawer");
            (_drawersMap$alias = drawersMap[alias]) === null || _drawersMap$alias === void 0 ? void 0 : _drawersMap$alias.handleUnderlayClick(event);
          } else {
            // Outside click
            Drawer.openDrawersList.forEach(drawer => drawer.handleOutsideClick(event));
          }
        }
      });
      document.addEventListener("keydown", event => {
        if (event.key === "Escape") {
          if (!Drawer.openDrawersList.length) return;
          Drawer.upperOpenDrawer.handleEsc(event);
        }
      });
    };
    kitchen.assign = function (target, alias, options) {
      if (alias in drawersMap) throw new Error("There is drawer already created with given alias: \"".concat(alias, "\""));
      const drawerElem = target instanceof HTMLElement ? target : document.querySelector(target);
      if (drawerElem) throw new Error("There is no element has been found by given selector: \"".concat(target, "\""));
      return drawersMap[alias] = new Drawer(drawerElem, alias, options);
    };
    kitchen.open = function (alias, initiator) {
      console.log("Open Drawer Kitchen", alias, initiator);
      if (!(alias in drawersMap)) throw new Error("There is no drawer created with given alias: \"".concat(alias, "\""));
      drawersMap[alias].open(initiator);
    };
    kitchen.close = function (alias) {
      console.log("Close Drawer Kitchen", alias);
      if (!(alias in drawersMap)) throw new Error("There is no drawer created with given alias: \"".concat(alias, "\""));
      drawersMap[alias].close();
    };
    kitchen.get = function (alias) {
      return drawersMap[alias];
    };
    kitchen.on = (alias, type, callback) => {
      var _kitchen$get;
      return (_kitchen$get = kitchen.get(alias)) === null || _kitchen$get === void 0 ? void 0 : _kitchen$get.on(type, callback);
    };
    return kitchen;
  })();
}
function bodyLock(targetElem) {
  lock(targetElem);
  const bodyElem = document.querySelector("body");
  bodyElem.classList.add("lock");
  const scrollableElems = targetElem.querySelectorAll("[data-scrollable]");
  scrollableElems.forEach(elem => lock(elem));
}
function bodyUnlock(targetElem) {
  let removeUnderlay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  let delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 300;
  const bodyElem = document.querySelector("body");
  setTimeout(() => {
    if (removeUnderlay) {
      bodyElem.classList.remove("lock");
    }
    unlock(targetElem);
    const scrollableElems = targetElem.querySelectorAll("[data-scrollable]");
    scrollableElems.forEach(elem => unlock(elem));
  }, delay);
}
;// CONCATENATED MODULE: ./repo/js/libs/portals.js


const portalsIndexByMedia = {};
const mediaIndex = {};
const onClassIndex = {};
const indexByName = {};
class Portal {
  constructor(name, src, dest) {
    this.name = name;
    this.src = src;
    this.dest = dest;
    this.state = {
      active: false
    };
  }
  send() {
    if (this.state.active) return this;
    this.dest.append(...this.src.childNodes);
    this.src.setAttribute("data-portal-active", "true");
    this.dest.setAttribute("data-portal-active", "true");
    this.state.active = true;
    debug("Portal has been activated: ", this);
    return this;
  }
  return() {
    if (!this.state.active) return this;
    this.src.append(...this.dest.childNodes);
    this.src.removeAttribute("data-portal-active");
    this.dest.removeAttribute("data-portal-active");
    this.state.active = false;
    debug("Portal has been de-activated: ", this.name);
    return this;
  }
  swap() {
    return this.state.active ? this.return() : this.send();
  }
}
function initPortals() {
  log("Start portals initialization");
  const sourceElems = document.querySelectorAll("[data-portal-src]");
  const destElems = document.querySelectorAll("[data-portal-dest]");
  const destMap = [].reduce.call(destElems, (result, elem) => {
    result[elem.getAttribute("data-portal-dest")] = elem;
    return result;
  }, {});

  // Activate portal on user defined class added
  initMutationObserver();
  sourceElems.forEach(elem => {
    const portalName = elem.getAttribute("data-portal-src");
    const portalMedia = elem.getAttribute("data-portal-media");
    const portalOnClass = elem.getAttribute("data-portal-on-class");
    debug("Initialize portal:: portalName: ", portalName, ", portalMedia: ", portalMedia, ", portalOnClass: ", portalOnClass);
    if (!destMap[portalName]) {
      debug("No destination for portal:: portalName: ", portalName);
      return;
    }
    indexByName[portalName] = new Portal(portalName, elem, destMap[portalName]);
    if (portalMedia) return addTriggerByMedia(portalName, portalMedia);
    if (portalOnClass) return initPortalDrivenByClass(portalName, portalOnClass);
  });
  debug("indexByName: ", indexByName, "portalsIndexByMedia: ", portalsIndexByMedia);
  Object.entries(mediaIndex).forEach(_ref => {
    let [media, mediaMatch] = _ref;
    return swapByMedia(mediaMatch);
  });
  window.portals = {
    getByName: name => indexByName[name]
  };
  function addTriggerByMedia(portalName, portalMedia) {
    debug("addTriggerByMedia: ", portalName, portalMedia);
    if (!mediaIndex[portalMedia]) {
      const mediaMatch = window.matchMedia(portalMedia);
      mediaIndex[portalMedia] = mediaMatch;
      portalsIndexByMedia[mediaMatch.media] = {
        mediaMatch,
        stack: [portalName]
      };
      mediaMatch.addListener(swapByMedia);
    } else {
      const trueMedia = mediaIndex[portalMedia].media;
      portalsIndexByMedia[trueMedia].stack.push(portalName);
    }
  }
  function initMutationObserver() {
    return new MutationObserver((mutationsList, observer) => {
      log(mutationsList);
    });
  }
  function initPortalDrivenByClass(className) {}
  function swapByMedia(_ref2) {
    let {
      matches,
      media
    } = _ref2;
    debug("Manipulate portals by media: ", media, ", matches: ", matches);
    if (matches) {
      portalsIndexByMedia[media].stack.forEach(portalName => indexByName[portalName].send());
    } else {
      portalsIndexByMedia[media].stack.forEach(portalName => indexByName[portalName].return());
    }
  }
}
;// CONCATENATED MODULE: ./repo/js/libs/input-service-classes.js
function initInputFocusTracking() {
  let root = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
  const nodes = root.querySelectorAll("[data-focus-receiver]");
  nodes.forEach(node => {
    const focusIndicator = node.closest("[data-focus-indicator]");
    if (focusIndicator) {
      node.addEventListener("focus", e => {
        focusIndicator.classList.add("focus");
      });
      node.addEventListener("blur", e => {
        focusIndicator.classList.remove("focus");
      });
    }
  });
}
function initInputCheckTracking() {
  let root = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
  const nodes = root.querySelectorAll("[data-check-receiver]");
  nodes.forEach(node => {
    const indicator = node.closest("[data-check-indicator]");
    if (indicator) {
      if (node.checked) {
        indicator.classList.add("checked");
      }
      node.addEventListener("change", e => {
        if (e.currentTarget.checked) {
          indicator.classList.add("checked");
        } else {
          indicator.classList.remove("checked");
        }
      });
    }
  });
}
function initRadioCheckTracking() {
  let root = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
  const elems = root.querySelectorAll("[data-radio]");
  let checked = {};
  elems.forEach(elem => {
    var _elem$form;
    const indicator = elem.closest("[data-radio-wrapper]");
    const formName = ((_elem$form = elem.form) === null || _elem$form === void 0 ? void 0 : _elem$form.getAttribute("name")) || "";
    const name = elem.name;
    if (indicator) {
      if (elem.checked) {
        indicator.classList.add("checked");
        checked["".concat(formName, "__").concat(name)] = indicator;
      }
      elem.addEventListener("change", event => {
        if (event.currentTarget.checked) {
          indicator.classList.add("checked");
          if (checked["".concat(formName, "__").concat(name)] && checked["".concat(formName, "__").concat(name)] !== indicator) {
            checked["".concat(formName, "__").concat(name)].classList.remove("checked");
            checked["".concat(formName, "__").concat(name)] = indicator;
          }
          checked["".concat(formName, "__").concat(name)] = indicator;
        } else {
          indicator.classList.remove("checked");
        }
      });
    }
  });
}
function trackFocus() {
  let root = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
  const targetElems = root.querySelectorAll("[data-track-child-focus]");
  targetElems.forEach(elem => {
    elem.addEventListener("focusin", e => {
      elem.classList.add("_focus");
    });
    elem.addEventListener("focusout", e => {
      elem.classList.remove("_focus");
    });
  });
}
function inputAutoSize() {
  const targetElems = document.querySelectorAll("[data-input-auto-size]");
  targetElems.forEach(elem => {
    const handler = e => {
      setTimeout(() => {
        e.target.style.width = "1px";
        requestAnimationFrame(() => {
          e.target.style.width = "".concat(e.target.scrollWidth, "px");
        });
      }, 1);
    };
    elem.addEventListener("blur", handler);
    elem.addEventListener("change", handler);
    elem.addEventListener("input", handler);
    handler({
      target: elem
    });
  });
}
;// CONCATENATED MODULE: ./src/js/shared/initCallbackRequestForm.js
function initCallbackRequestForm(formId) {
  let formType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "callback";
  // or "loan"
  const $form = $("#".concat(formId));
  const validator = $form.validate({
    ignore: [],
    highlight: function (element, errorClass, validClass) {
      $(element).closest(".form-field").addClass(errorClass);
    },
    unhighlight: function (element, errorClass, validClass) {
      $(element).closest(".form-field").removeClass(errorClass);
    },
    errorPlacement: function (error, element) {
      error.appendTo(element.closest(".form-field"));
    }
    // Отправляем данные на сервер
    // submitHandler: async function(form, event) {
    // 	event.preventDefault();
    // 	drawers.open("successful-callback-request");
    // const formData = new FormData(form);
    // const response = await fetch(``, {
    // 	method: "POST",
    // 	body: formData,
    // 	redirect: 'follow'
    // });
    // if (response.ok) {
    // 	drawers.open("successful-callback-request");
    // } else {
    // 	console.error("Ошибка при отпрвке/обработке формы запороса обратного звонка: status::" + response.status + ", statusText::" + response.statusText);
    // }
    //}
  });

  const $telInputElem = $form.find("input[name='tel']");
  const cleave = new Cleave($telInputElem.get(0), {
    numericOnly: true,
    blocks: [2, 3, 3, 2, 2],
    delimiters: [" (", ") ", "-", "-"],
    prefix: "+7",
    noImmediatePrefix: true
  });
  return validator;
}
;// CONCATENATED MODULE: ./repo/js/libs/initIntersectionAnimations.js
function initIntersectionAnimations() {
  const map = new Map();
  const observer = new IntersectionObserver(entries => {
    entries.forEach(_ref => {
      let {
        target,
        isIntersecting,
        boundingClientRect
      } = _ref;
      if (!map.has(target)) return;
      const animatedElem = map.get(target);
      const animationClassesOnEnter = extractAnimationClasses(animatedElem, "data-animate-on-enter");
      const animationClassesOnOut = extractAnimationClasses(animatedElem, "data-animate-on-out");
      if (isIntersecting || boundingClientRect.top < 0) {
        animatedElem.classList.remove(...animationClassesOnOut);
        animatedElem.classList.add(...animationClassesOnEnter);
      } else {
        animatedElem.classList.remove(...animationClassesOnEnter);
        animatedElem.classList.add(...animationClassesOnOut);
      }
    });
  }, {
    rootMargin: "0px",
    threshold: 0.3
  });
  const targetElems = document.querySelectorAll("[data-animate-on-enter]");
  targetElems.forEach(elem => {
    const intersectionTarget = elem.getAttribute("data-intersection-target");
    if (!intersectionTarget || intersectionTarget === "this") {
      observe(elem);
    } else if (intersectionTarget === "parent") {
      observe(elem.parentElement, elem);
    } else if (intersectionTarget.startsWith("closest:")) {
      const match = intersectionTarget.match(/^closest:\s*(.+)/);
      if (match) {
        const target = elem.closest(match[1]);
        if (target) {
          observe(target, elem);
        }
      }
    } else if (intersectionTarget.startsWith("query:")) {
      const match = intersectionTarget.match(/^query:\s*(.+)/);
      if (match) {
        const target = document.querySelector(match[1]);
        if (target) {
          observe(target, elem);
        }
      }
    }
  });
  function observe(observable, animated) {
    console.log(observable, animated);
    map.set(observable, animated || observable);
    observer.observe(observable);
  }
  function extractAnimationClasses(target, attribute) {
    const animationClasses = target.getAttribute(attribute);
    return animationClasses && animationClasses.split(/[,\s]+/) || [];
  }
}
;// CONCATENATED MODULE: ./src/js/common/index.js







window.addEventListener("DOMContentLoaded", onLoaded);
function onLoaded() {
  try {
    initPortals();
    drawers.init();
    trackFocus();
    initCloseDrawersOnResize();
    initMarkOnScroll();
    addIsMobileClass();
    initCallbackRequestForm("footer-callback-request-form");
    initIntersectionAnimations();
    initCallbackRequestBtns();
    initMainMenuAutoclose();
    //initFooterCallbackRequestBtn();
  } catch (ex) {
    error(ex);
  }
}
function addIsMobileClass() {
  if (isMobile.any()) {
    document.documentElement.classList.add("is-mobile");
  }
}
function initCloseDrawersOnResize() {
  const close = _ref => {
    let {
      matches
    } = _ref;
    drawers.get("main-menu").close();
  };
  const mediaMatch = window.matchMedia("(max-width: 1400px)");
  mediaMatch.addListener(close);
}
function initMarkOnScroll() {
  document.addEventListener("scroll", () => {
    if (window.scrollY > 80) {
      document.documentElement.classList.add("scroll-80-plus");
    } else {
      document.documentElement.classList.remove("scroll-80-plus");
    }
  });
}
function initCallbackRequestBtns() {
  const formFirstFieldElem = document.forms["callback-request"].name;
  const elems = document.querySelectorAll("[data-callback-request-btn]");
  elems.forEach(elem => {
    elem.addEventListener("click", event => {
      event.preventDefault();
      formFirstFieldElem.focus();
    });
  });
}
// function initFooterCallbackRequestBtn() {
// 	const $elem = $("#footer-callback-request-btn");
// 	const $capElem = $elem.children(".btn__cap");
// 	const defaultText = $capElem.text();
// 	const adaptiveText = $capElem.attr("data-tablet-text");
// 	const mediaMatch = matchMedia("(min-width: 1024.1px) and (max-width: 1400px)");
// 	const matchHandler = ({ matches }) => {
// 		if (matches) {
// 			$capElem.text(adaptiveText);
// 		} else {
// 			$capElem.text(defaultText);
// 		}
// 	}
// 	mediaMatch.addListener(matchHandler);
// 	matchHandler(mediaMatch);
// }

function initMainMenuAutoclose() {
  const elem = document.querySelector("[data-drawer='main-menu']");
  elem.addEventListener("click", _ref2 => {
    let {
      target
    } = _ref2;
    if (target.closest(".ative-item, .btn") || target.classList.contains("ative-item") || target.classList.contains("btn")) {
      drawers.close("main-menu");
    }
  });
}
}();
// This entry need to be wrapped in an IIFE because it need to be isolated against other entry modules.
!function() {
// extracted by mini-css-extract-plugin

}();
/******/ })()
;